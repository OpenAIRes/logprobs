<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Logprobs Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body        { font: 16px/1.5 system-ui, sans-serif; margin: 0; padding: 1rem; }
    #header     { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; }
    #tokens     { max-width: 100%; line-height: 1.5; white-space: normal; }
    .token      { display: inline; cursor: pointer; }
    .token:hover{ background: #ffeaa7; }
    .newline    { display: block; width: 100%; }
    .newline:hover { background: #ffeaa7; }
    .selected   { background: #74b9ff; }

    #tooltip {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      padding: .5rem;
      font: 14px/1.3 monospace;
      box-shadow: 0 2px 6px #0003;
      z-index: 1000;
      max-width: 90vw;
      overflow-x: auto;
    }
    #tooltip.hidden { display:none; }
    #tooltip table  { border-collapse: collapse; margin-top: .25rem; width: 100%; }
    #tooltip th,
    #tooltip td     { padding: .15rem .5rem; border: 1px solid #ddd; }
    #tooltip tr.best td { background: #dfe6e9; font-weight: bold; }
    #loading  { color: #888; }
    button    { padding: 0.4rem 0.8rem; font-size: 14px; cursor: pointer; margin-left: 0.5rem; margin-top: 0.5rem; }
    #status   { font-size: 14px; color: #2d3436; margin-left: 1rem; }
    #status.error { color: #d63031; }
    #savedCount { margin-left: 0.5rem; font-weight: bold; }
  </style>
</head>
<body>
  <div id="header">
    <div>
      <span id="loading">Loading tokens…</span>
      <span id="status"></span>
    </div>
    <div>
      <!-- Odebráno tlačítko Pokračovat (16) -->
      <button id="continueBtn256" hidden>max_tokens=256</button>
<button id="exportBtn" hidden>Export (<span id="savedCount">0</span>)</button>
      <button id="clearBtn" hidden>Clear</button>
    </div>
  </div>
  <div id="tokens" hidden></div>
  <div id="tooltip" class="hidden"></div>

<script>
let allTokens = [];
let safeTokens = [];
let currentCompletionId = null;

const tokensEl = document.getElementById('tokens');
const loadingEl = document.getElementById('loading');
const tooltipEl = document.getElementById('tooltip');
const exportBtn = document.getElementById('exportBtn');
const clearBtn = document.getElementById('clearBtn');
const continueBtn256 = document.getElementById('continueBtn256');
const statusEl = document.getElementById('status');
const savedCountEl = document.getElementById('savedCount');

function escapeToken(tok){return tok.replace(/\n/g,'\\n').replace(/\t/g,'\\t').replace(/ /g,'␣');}
function showStatus(msg){statusEl.textContent=msg;statusEl.classList.remove('error');setTimeout(()=>{statusEl.textContent='';},2000);} 
function updateSavedCount(){const h=JSON.parse(localStorage.getItem('completion_history')||'[]');savedCountEl.textContent=h.length;}

/* ============ INITIAL LOAD ============ */
async function loadTokens() {
  try {
    const res = await fetch('logprobs.json');
    const data = await res.json();

    let firstEntry;
    if (data.object === "text_completion") {
      // Standard completions
      const lp = data.choices[0].logprobs;
      allTokens = lp.tokens.map((t, i) => {
        const sorted = Object.entries(lp.top_logprobs[i])
          .map(([tok, log]) => ({ token: tok, logprob: log }))
          .sort((a, b) => b.logprob - a.logprob);
        return { token: t, logprob: lp.token_logprobs[i], top_logprobs: sorted };
      });
      safeTokens = allTokens.map(t => t.token);
      currentCompletionId = data.id;

      firstEntry = {
        id: data.id,
        object: "text_completion",
        created: data.created || Math.floor(Date.now()/1000),
        model: data.model,
        previous_response_id: null,
        prompt: {
          text: (typeof data.prompt === 'string' ? data.prompt : Array.isArray(data.prompt) ? data.prompt.join('') : ''),
          index: 0,
          logprobs: { tokens: ((typeof data.prompt === 'string' && data.prompt) ? [data.prompt] : (Array.isArray(data.prompt) && data.prompt.length ? [data.prompt.join('')] : [])), token_logprobs: [], top_logprobs: [] }
        },
        choices: [
          {
            text: data.choices[0].text,
            index: 0,
            logprobs: lp,
            finish_reason: data.choices[0].finish_reason
          }
        ],
        usage: data.usage || {
          prompt_tokens: 0,
          completion_tokens: lp.tokens.length,
          total_tokens: lp.tokens.length
        },
        max_tokens: 16,
        temperature: 0,
        seed: 0
      };
    } else if (data.object === "chat.completion") {
      // Chat completions
      const lp = data.choices[0].logprobs;
      allTokens = lp.content.map(item => {
        const sorted = (item.top_logprobs || [])
          .map(t => ({ token: t.token, logprob: t.logprob }))
          .sort((a,b) => b.logprob - a.logprob);
        return { token: item.token, logprob: item.logprob, top_logprobs: sorted };
      });
      safeTokens = allTokens.map(t => t.token);
      currentCompletionId = data.id;

      firstEntry = {
        id: data.id,
        object: "chat.completion",
        created: data.created || Math.floor(Date.now()/1000),
        model: data.model,
        previous_response_id: null,
        prompt: {
          text: "", // Chat prompt se neukládá explicitně
          index: 0,
          logprobs: { tokens: [], token_logprobs: [], top_logprobs: [] }
        },
        choices: [
          {
            text: data.choices[0].message?.content || "",
            index: 0,
            logprobs: {
              tokens: lp.content.map(t => t.token),
              token_logprobs: lp.content.map(t => t.logprob),
              top_logprobs: lp.content.map(t => {
                const obj = {};
                (t.top_logprobs || []).forEach(tt => obj[tt.token] = tt.logprob);
                return obj;
              })
            },
            finish_reason: data.choices[0].finish_reason
          }
        ],
        usage: data.usage,
        max_tokens: 16,
        temperature: 0,
        seed: 0
      };
    } else {
      throw new Error("Unsupported JSON format");
    }

    const history = JSON.parse(localStorage.getItem('completion_history') || '[]');
    if (history.length === 0) {
      history.push(firstEntry);
      localStorage.setItem('completion_history', JSON.stringify(history));
    }

    renderTokens(allTokens);
    exportBtn.hidden = false;
    clearBtn.hidden = false;
    if (continueBtn256) continueBtn256.hidden = false;
    updateSavedCount();
    loadingEl.remove();
  } catch (err) {
    loadingEl.textContent = 'Error loading logprobs.json: ' + err.message;
    statusEl.textContent = '';
  }
}

/* ============ HISTORY FUNCTIONS ============ */
function getCompletionById(id) {
  const history = JSON.parse(localStorage.getItem('completion_history') || '[]');
  const entry = history.find(e => e.id === id);
  if (!entry) return null;

  const promptTokensUI = entry.prompt.logprobs.tokens.map((t, i) => {
    const logprob = entry.prompt.logprobs.token_logprobs[i] || null;
    const top = entry.prompt.logprobs.top_logprobs[i] || {};
    const sorted = Object.entries(top).map(([tok, log]) => ({ token: tok, logprob: log })).sort((a,b)=>b.logprob-a.logprob);
    return { token: t, logprob, top_logprobs: sorted };
  });

  const completionTokensUI = entry.choices[0].logprobs.tokens.map((t, i) => {
    const top = entry.choices[0].logprobs.top_logprobs[i] || {};
    const sorted = Object.entries(top).map(([tok, log]) => ({ token: tok, logprob: log })).sort((a,b)=>b.logprob-a.logprob);
    return { token: t, logprob: entry.choices[0].logprobs.token_logprobs[i], top_logprobs: sorted };
  });

  return {
    promptTokens: entry.prompt.logprobs.tokens,
    completionTokens: entry.choices[0].logprobs.tokens,
    allTokens: promptTokensUI.concat(completionTokensUI)
  };
}

/* ============ CREATE COMPLETION ============ */
async function createCompletion(prevId, replaceIdx, newToken, maxTokens) {
  const prev = getCompletionById(prevId);
  if (!prev) {
    console.error('[ERROR] Previous completion not found for ID:', prevId);
    showStatus('Previous completion not found');
    return null;
  }

  const allTokensArr = prev.promptTokens.concat(prev.completionTokens);
  const updatedTokens = allTokensArr.slice(0, replaceIdx);
  if (newToken !== undefined && newToken !== null) updatedTokens.push(newToken);
  const promptText = updatedTokens.join('');

  const history = JSON.parse(localStorage.getItem('completion_history') || '[]');

  const existing = history.find(e => JSON.stringify(e.prompt.logprobs.tokens) === JSON.stringify(updatedTokens) && Number(e.max_tokens) === Number(maxTokens));
  if (existing) {
    console.log('[HIT] Found existing completion');
    return {
      response: { id: existing.id, choices: existing.choices },
      prompt: promptText,
      fromHistory: true
    };
  }

  console.log('[MISS] Calling API for prompt:', promptText);

  const key = await ensureApiKey();
  if (!key) return null;

  const data = await fetchCompletion(promptText, maxTokens, key);
  if (!data) return null;

  const lp = data.choices[0].logprobs;

  const newEntry = {
    id: data.id,
    object: "text_completion",
    created: Math.floor(Date.now() / 1000),
    model: data.model,
    previous_response_id: prevId,
    prompt: {
      text: promptText,
      index: 0,
      logprobs: { tokens: updatedTokens, token_logprobs: [], top_logprobs: [] }
    },
    choices: [
      {
        text: data.choices[0].text,
        index: 0,
        logprobs: lp,
        finish_reason: data.choices[0].finish_reason
      }
    ],
    usage: data.usage,
    max_tokens: maxTokens,
    temperature: 0,
    seed: 0
  };

  const history2 = JSON.parse(localStorage.getItem('completion_history') || '[]');
  history2.push(newEntry);
  localStorage.setItem('completion_history', JSON.stringify(history2));
  updateSavedCount();

  return { response: data, prompt: promptText, fromHistory: false };
}

/* ============ CONTINUE (PROMPT ONLY) ============ */
async function continueFromPromptOnly(maxTokens) {
  const prevId = currentCompletionId;
  const prev = getCompletionById(prevId);
  if (!prev) {
    console.error('[ERROR] Cannot continue: previous completion not found');
    showStatus('Nelze pokračovat – chybí aktuální záznam');
    return;
  }

  // Použij pouze původní prompt (bez completionu). Fallback pro chat: když není prompt, použij celé zobrazení.
  const promptOnlyIdx = prev.promptTokens.length > 0 ? prev.promptTokens.length : 0;

  const result = await createCompletion(prevId, promptOnlyIdx, undefined, maxTokens);
  if (!result) return;

  const lp = result.response.choices[0].logprobs;
  const newTokens = lp.tokens.map((t, i) => {
    const sorted = Object.entries(lp.top_logprobs[i])
      .map(([tok, log]) => ({ token: tok, logprob: log }))
      .sort((a, b) => b.logprob - a.logprob);
    return { token: t, logprob: lp.token_logprobs[i], top_logprobs: sorted };
  });
  const promptLen = prev.promptTokens.length > 0 ? prev.promptTokens.length : allTokens.length;
  allTokens = allTokens.slice(0, promptLen).concat(newTokens);
  safeTokens = allTokens.map(t => t.token);
  currentCompletionId = result.response.id;
  renderTokens(allTokens);
  showStatus(result.fromHistory ? 'Načteno!' : 'Pokračování (z promptu) nahrazeno!');
}

/* ============ API HELPER ============ */
async function fetchCompletion(prompt, maxTokens, key){
  try{
    const res = await fetch('https://api.openai.com/v1/completions',{
      method:'POST',
      headers:{
        'Content-Type':'application/json',
        'Authorization':`Bearer ${key||await ensureApiKey()}`
      },
      body:JSON.stringify({
        model:'gpt-3.5-turbo-instruct',
        prompt,
        logprobs:20,
        max_tokens:maxTokens,
        temperature:0,
        seed:0
      })
    });
    const data = await res.json(); 
    if(data.error){
      statusEl.textContent=`Error: ${data.error.message}`; 
      statusEl.classList.add('error'); 
      return null;
    }
    return data;
  }catch{return null;}
}

/* ============ APPLY COMPLETION ============ */
function applyCompletion(response, idx, replacementToken){
  const lp=response.choices[0].logprobs;
  const newTokens=lp.tokens.map((t,i)=>{
    const sorted=Object.entries(lp.top_logprobs[i])
      .map(([tok,log])=>({token:tok,logprob:log}))
      .sort((a,b)=>b.logprob-a.logprob);
    return {token:t,logprob:lp.token_logprobs[i],top_logprobs:sorted};
  });

  const replacedObj={token:replacementToken,logprob:0,top_logprobs:allTokens[idx]?.top_logprobs||[]};
  allTokens=allTokens.slice(0,idx).concat(replacedObj,newTokens);
  safeTokens=allTokens.map(t=>t.token);
  currentCompletionId=response.id;
  renderTokens(allTokens); 
  tooltipEl.classList.add('hidden');
}

/* ============ UI RENDERING ============ */
function renderTokens(tokens){
  tokensEl.innerHTML=''; let i=0; const BATCH=1200;
  function chunk(){
    const frag=document.createDocumentFragment();
    for(let j=0;j<BATCH&&i<tokens.length;j++,i++){
      const t=tokens[i];
      const span=document.createElement('span');
      span.dataset.idx=i;
      if(t.token.includes('\n')){
        span.className='token newline';
        span.style.height=`${1.2*(t.token.match(/\n/g)||[]).length}em`;
      }else{ span.className='token'; span.textContent=t.token; }
      span.title=escapeToken(t.token);
      span.addEventListener('click',e=>handleTokenClick(e,tokens));
      frag.appendChild(span);
    }
    tokensEl.appendChild(frag);
    if(i<tokens.length){requestAnimationFrame(chunk);}else{tokensEl.hidden=false;}
  }
  chunk();
}

function clearSelection(){tokensEl.querySelectorAll('.selected').forEach(el=>el.classList.remove('selected'));}
function handleTokenClick(e,tokens){
  e.stopPropagation();
  const idx=+e.currentTarget.dataset.idx;
  clearSelection();
  showTopLogprobs(e,tokens,idx);
}

function showTopLogprobs(e,tokens,idx){
  const {token,top_logprobs}=tokens[idx];
  const rows=top_logprobs.slice(0,20).map((r,idx2)=>`<tr class="${idx2===0?'best':''}"><td class="tok" data-idx="${idx}" data-alt="${r.token}">${escapeToken(r.token)}</td><td>${r.logprob.toFixed(2)}</td><td>${Math.exp(r.logprob).toFixed(6)}</td></tr>`).join('');
  tooltipEl.innerHTML=`<strong data-idx="${idx}">Token: "${escapeToken(token)}"</strong><br><table><tr><th>token</th><th>log p</th><th>p</th></tr>${rows}</table>`;
  tooltipEl.classList.remove('hidden'); 
  tooltipEl.querySelectorAll('.tok').forEach(td=>td.addEventListener('click',completion)); 
  positionTooltip(e);
}

function positionTooltip(e){
  const rect = e.currentTarget.getBoundingClientRect();

  // Zviditelnit kvůli měření, ale neukazovat
  const prevVis = tooltipEl.style.visibility;
  tooltipEl.classList.remove('hidden');
  tooltipEl.style.visibility = 'hidden';
  tooltipEl.style.top = '0px';
  tooltipEl.style.left = '0px';

  const tRect = tooltipEl.getBoundingClientRect();

  let top  = rect.bottom + window.scrollY + 4;
  let left = rect.left   + window.scrollX;

  // hranice viewportu
  const vwLeft  = window.scrollX;
  const vwRight = window.scrollX + window.innerWidth;
  const vwTop   = window.scrollY;
  const vwBot   = window.scrollY + window.innerHeight;

  if (left + tRect.width > vwRight) left = vwRight - tRect.width - 4;
  if (top  + tRect.height > vwBot)  top  = rect.top + window.scrollY - tRect.height - 4;
  if (left < vwLeft) left = vwLeft + 4;
  if (top  < vwTop)  top  = rect.bottom + window.scrollY + 4;

  tooltipEl.style.top = `${top}px`;
  tooltipEl.style.left = `${left}px`;
  tooltipEl.style.visibility = prevVis || '';
}
  
async function completion(e){
  e.stopPropagation();
  const idx=+e.currentTarget.dataset.idx;
  const altToken=e.currentTarget.dataset.alt; if(altToken===undefined) return;
  const result=await createCompletion(currentCompletionId,idx,altToken,16);
  if(!result) return;
  applyCompletion(result.response,idx,altToken);
  showStatus(result.fromHistory ? 'Načteno!' : 'Uloženo!');
}

async function ensureApiKey(){
  let key=localStorage.getItem('openai_key'); 
  if(!key){
    key=window.prompt('OpenAI API key:'); 
    if(!key) return null; 
    localStorage.setItem('openai_key',key);
  } 
  return key;
}

/* ============ EXPORT / CLEAR ============ */
exportBtn.addEventListener('click',()=>{
  const h=localStorage.getItem('completion_history'); 
  if(!h||h==='[]'){alert('No completions saved yet.');return;} 
  const blob=new Blob([h],{type:'application/json'}); 
  const url=URL.createObjectURL(blob); 
  const a=document.createElement('a'); 
  a.href=url; a.download='completion_history.json'; 
  a.click(); 
  URL.revokeObjectURL(url);
});

clearBtn.addEventListener('click',()=>{
  localStorage.removeItem('completion_history'); 
  updateSavedCount(); 
  showStatus('Historie vymazána');
});

// Nové chování: pokračovat z POUHÉHO promptu
if (continueBtn256) continueBtn256.addEventListener('click',()=>continueFromPromptOnly(256));

document.addEventListener('click',()=>tooltipEl.classList.add('hidden'),{passive:true});
window.addEventListener('DOMContentLoaded',loadTokens);
</script>
</body>
</html>
