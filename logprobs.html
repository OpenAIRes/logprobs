<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Logprobs Viewer (Full Chain Restore)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <style>
    body        { font: 16px/1.5 system-ui, sans-serif; margin: 0; padding: 1rem; }
    #header     { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; }
    #tokens     { max-width: 100%; line-height: 1.5; white-space: normal; }
    .token      { display: inline; cursor: pointer; }
    .token:hover{ background: #ffeaa7; }
    .newline    { display: block; width: 100%; }
    .newline:hover { background: #ffeaa7; }
    .selected   { background: #74b9ff; }

    #tooltip {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      padding: .5rem;
      font: 14px/1.3 monospace;
      box-shadow: 0 2px 6px #0003;
      z-index: 1000;
      max-width: 90vw;
      overflow-x: auto;
    }
    #tooltip.hidden { display:none; }
    #tooltip table  { border-collapse: collapse; margin-top: .25rem; width: 100%; }
    #tooltip th,
    #tooltip td     { padding: .15rem .5rem; border: 1px solid #ddd; }
    #tooltip tr.best td { background: #dfe6e9; font-weight: bold; }
    #loading  { color: #888; }
    button    { padding: 0.4rem 0.8rem; font-size: 14px; cursor: pointer; margin-left: 0.5rem; margin-top: 0.5rem; }
    #status   { font-size: 14px; color: #2d3436; margin-left: 1rem; }
    #status.error { color: #d63031; }
    #savedCount { margin-left: 0.5rem; font-weight: bold; }
  </style>
</head>
<body>
  <div id="header">
    <div>
      <span id="loading">Loading tokens…</span>
      <span id="status"></span>
    </div>
    <div>
      <button id="continueBtn16" hidden>Pokračovat (16)</button>
      <button id="continueBtn256" hidden>Pokračovat (256)</button>
      <button id="exportBtn" hidden>Export (<span id="savedCount">0</span>)</button>
      <button id="clearBtn" hidden>Clear</button>
    </div>
  </div>
  <div id="tokens" hidden></div>
  <div id="tooltip" class="hidden"></div>

<script>
const tokensEl  = document.getElementById('tokens');
const loadingEl = document.getElementById('loading');
const tooltipEl = document.getElementById('tooltip');
const exportBtn = document.getElementById('exportBtn');
const clearBtn  = document.getElementById('clearBtn');
const continueBtn16 = document.getElementById('continueBtn16');
const continueBtn256 = document.getElementById('continueBtn256');
const statusEl  = document.getElementById('status');
const savedCountEl = document.getElementById('savedCount');

let allTokens = [];
let selectionStart = null;

function escapeToken(token) {
  return token
    .replace(/\n/g, '\\n')
    .replace(/\t/g, '\\t')
    .replace(/ /g, '␣'); // vizuálně rozlišit mezery
}

async function loadTokens () {
  try {
    const res  = await fetch('logprobs.json');
    const data = await res.json();

    if (data.object === 'chat.completion') {
      allTokens = data.choices[0].logprobs.content.map(t => ({
        token: t.token,
        logprob: t.logprob,
        top_logprobs: [...t.top_logprobs].sort((a, b) => b.logprob - a.logprob)
      }));
    } else if (data.object === 'text_completion' || data.object === 'text.completion') {
      const lp = data.choices[0].logprobs;
      allTokens = lp.tokens.map((token, i) => {
        const sortedTop = Object.entries(lp.top_logprobs[i])
          .map(([tok, log]) => ({ token: tok, logprob: log }))
          .sort((a, b) => b.logprob - a.logprob);
        return { token, logprob: lp.token_logprobs[i], top_logprobs: sortedTop };
      });
    } else {
      throw new Error('Unsupported format: ' + data.object);
    }

    renderTokens(allTokens);
    exportBtn.hidden = false;
    clearBtn.hidden = false;
    continueBtn16.hidden = false;
    continueBtn256.hidden = false;
    updateSavedCount();

    restoreContinuations(); // ✅ nové: načti všechna navazující pokračování
  } catch (err) {
    loadingEl.textContent = 'Error loading logprobs.json: ' + err.message;
    statusEl.textContent = '';
  }
}

function restoreContinuations() {
  const history = JSON.parse(localStorage.getItem('completion_history') || '[]');
  let currentPrompt = allTokens.map(t => t.token).join('');
  let foundAny = false;

  while (true) {
    const next = history.find(entry => entry.prompt === currentPrompt);
    if (!next) break;
    appendCompletion(next.response);
    currentPrompt = allTokens.map(t => t.token).join('');
    foundAny = true;
  }

  if (foundAny) showStatus('Načtena uložená pokračování');
}

function renderTokens(tokens) {
  tokensEl.innerHTML = '';
  let i = 0;
  const BATCH = 1200;

  function chunk() {
    const frag = document.createDocumentFragment();
    for (let j = 0; j < BATCH && i < tokens.length; j++, i++) {
      const t = tokens[i];
      if (t.token.includes('\n')) {
        const count = (t.token.match(/\n/g) || []).length;
        const span = document.createElement('span');
        span.className = 'token newline';
        span.style.height = `${1.2 * count}em`;
        span.dataset.idx = i;
        span.title = escapeToken(t.token);
        span.addEventListener('click', e => handleTokenClick(e, tokens));
        frag.appendChild(span);
      } else {
        const span = document.createElement('span');
        span.className = 'token';
        span.dataset.idx = i;
        span.textContent = t.token;
        span.title = escapeToken(t.token);
        span.addEventListener('click', e => handleTokenClick(e, tokens));
        frag.appendChild(span);
      }
    }
    tokensEl.appendChild(frag);

    if (i < tokens.length) {
      requestAnimationFrame(chunk);
    } else {
      loadingEl.remove();
      tokensEl.hidden = false;
    }
  }
  chunk();
}

function clearSelection () {
  tokensEl.querySelectorAll('.selected').forEach(el =>
    el.classList.remove('selected')
  );
}

function handleTokenClick (e, tokens) {
  e.stopPropagation();
  const idx = +e.currentTarget.dataset.idx;
  if (e.shiftKey) {
    if (selectionStart === null) {
      selectionStart = idx;
      clearSelection();
      e.currentTarget.classList.add('selected');
    } else {
      const start = Math.min(selectionStart, idx);
      const end   = Math.max(selectionStart, idx);
      clearSelection();
      for (let j = start; j <= end; j++) {
        tokensEl.children[j].classList.add('selected');
      }
      const logSum = tokens.slice(start, end + 1)
        .reduce((s, t) => s + t.logprob, 0);
      tooltipEl.innerHTML =
        `<strong>Sequence</strong><br>` +
        `log p = ${logSum.toFixed(2)}<br>` +
        `p = ${Math.exp(logSum).toFixed(4)}`;
      tooltipEl.classList.remove('hidden');
      positionTooltip(e);
      selectionStart = null;
    }
  } else {
    clearSelection();
    selectionStart = null;
    showTopLogprobs(e, tokens);
  }
}

function showTopLogprobs (e, tokens) {
  e.stopPropagation();
  const i = +e.currentTarget.dataset.idx;
  const { token, top_logprobs } = tokens[i];

  const rows = top_logprobs.slice(0, 20).map((r, idx) =>
    `<tr class="prob-row ${idx === 0 ? 'best' : ''}">
       <td class="tok" data-idx="${i}" data-alt="${r.token}">${escapeToken(r.token)}</td>
       <td>${r.logprob.toFixed(2)}</td>
       <td>${Math.exp(r.logprob).toFixed(6)}</td>
     </tr>`
  ).join('');

  tooltipEl.innerHTML =
    `<strong data-idx="${i}">Token: "${escapeToken(token)}"</strong><br>` +
    '<table><tr><th>token</th><th>log p</th><th>p</th></tr>' +
    rows + '</table>';
  tooltipEl.classList.remove('hidden');

  tooltipEl.querySelectorAll('.prob-row .tok').forEach(td =>
    td.addEventListener('click', completion)
  );

  positionTooltip(e);
}

function positionTooltip (e) {
  const rect = e.currentTarget.getBoundingClientRect();
  const tRect = tooltipEl.getBoundingClientRect();
  let top  = rect.bottom + window.scrollY + 4;
  let left = rect.left + window.scrollX;

  if (left + tRect.width > window.innerWidth) {
    left = window.innerWidth - tRect.width - 4;
  }
  if (top + tRect.height > window.innerHeight + window.scrollY) {
    top = rect.top + window.scrollY - tRect.height - 4;
  }

  tooltipEl.style.top  = `${top}px`;
  tooltipEl.style.left = `${left}px`;
}

async function completion (e) {
  e.stopPropagation();
  const idx   = +e.currentTarget.dataset.idx;
  // Use the original token value from data attributes to avoid
  // UI transformations (e.g. escaped whitespace) altering the
  // text sent to the API.
  const token = e.currentTarget.dataset.alt;
  if (token === undefined) return;
  const prompt = allTokens.slice(0, idx).map(t => t.token).join('') + token;

  const key = await ensureApiKey();
  if (!key) return;

  const history = JSON.parse(localStorage.getItem('completion_history') || '[]');
  const existing = history.find(entry => entry.prompt === prompt);
  if (existing) {
    applyCompletion(existing.response, idx, token);
    showStatus('Načteno z historie');
    return;
  }

  try {
    const data = await fetchCompletion(prompt, 16);
    if (!data) return;

    applyCompletion(data, idx, token);

    history.push({
      timestamp: new Date().toISOString(),
      prompt,
      model: 'gpt-3.5-turbo-instruct',
      seed: 0,
      temperature: 0,
      max_tokens: 16,
      system_fingerprint: data.system_fingerprint || null,
      response: data
    });
    localStorage.setItem('completion_history', JSON.stringify(history));
    updateSavedCount();
    showStatus('Uloženo!');
  } catch (err) {
    statusEl.textContent = 'Fetch failed: ' + err.message;
    statusEl.classList.add('error');
  }
}

async function continueText(maxTokens) {
  const prompt = allTokens.map(t => t.token).join('');
  const key = await ensureApiKey();
  if (!key) return;

  const history = JSON.parse(localStorage.getItem('completion_history') || '[]');

  try {
    const data = await fetchCompletion(prompt, maxTokens);
    if (!data) return;

    appendCompletion(data);
    history.push({
      timestamp: new Date().toISOString(),
      prompt,
      model: 'gpt-3.5-turbo-instruct',
      seed: 0,
      temperature: 0,
      max_tokens: maxTokens,
      system_fingerprint: data.system_fingerprint || null,
      response: data
    });
    localStorage.setItem('completion_history', JSON.stringify(history));
    updateSavedCount();
    showStatus(`Pokračování ${maxTokens} tokenů uloženo!`);
  } catch (err) {
    statusEl.textContent = 'Fetch failed: ' + err.message;
    statusEl.classList.add('error');
  }
}

async function fetchCompletion(prompt, maxTokens) {
  try {
    const res = await fetch('https://api.openai.com/v1/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${await ensureApiKey()}`
      },
      body: JSON.stringify({
        model: 'gpt-3.5-turbo-instruct',
        prompt,
        logprobs: 20,
        max_tokens: maxTokens,
        temperature: 0,
        seed: 0
      })
    });
    const data = await res.json();
    if (data.error) {
      statusEl.textContent = `Error: ${data.error.message}`;
      statusEl.classList.add('error');
      return null;
    }
    return data;
  } catch {
    return null;
  }
}

function applyCompletion(response, idx, token) {
  const choice = response.choices[0];
  const lp = choice.logprobs;
  const newTokens = lp.tokens.map((t, i) => {
    const sortedTop = Object.entries(lp.top_logprobs[i])
      .map(([tok, log]) => ({ token: tok, logprob: log }))
      .sort((a,b) => b.logprob - a.logprob);
    return { token: t, logprob: lp.token_logprobs[i], top_logprobs: sortedTop };
  });

  const selectedTokenObj = {
    token,
    logprob: 0,
    top_logprobs: allTokens[idx].top_logprobs || []
  };

  allTokens = allTokens.slice(0, idx).concat(selectedTokenObj, newTokens);
  renderTokens(allTokens);
  tooltipEl.classList.add('hidden');
}

function appendCompletion(response) {
  const choice = response.choices[0];
  const lp = choice.logprobs;
  const newTokens = lp.tokens.map((t, i) => {
    const sortedTop = Object.entries(lp.top_logprobs[i])
      .map(([tok, log]) => ({ token: tok, logprob: log }))
      .sort((a,b) => b.logprob - a.logprob);
    return { token: t, logprob: lp.token_logprobs[i], top_logprobs: sortedTop };
  });

  allTokens = allTokens.concat(newTokens);
  renderTokens(allTokens);
  tooltipEl.classList.add('hidden');
}

async function ensureApiKey() {
  let key = localStorage.getItem('openai_key');
  if (!key) {
    key = window.prompt('OpenAI API key:');
    if (!key) return null;
    localStorage.setItem('openai_key', key);
  }
  return key;
}

function updateSavedCount() {
  const history = JSON.parse(localStorage.getItem('completion_history') || '[]');
  savedCountEl.textContent = history.length;
}

function showStatus(msg) {
  statusEl.textContent = msg;
  statusEl.classList.remove('error');
  setTimeout(() => { statusEl.textContent = ''; }, 2000);
}

exportBtn.addEventListener('click', () => {
  const history = localStorage.getItem('completion_history');
  if (!history || history === '[]') {
    alert('No completions saved yet.');
    return;
  }
  const blob = new Blob([history], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'completion_history.json';
  a.click();
  URL.revokeObjectURL(url);
});

clearBtn.addEventListener('click', () => {
  localStorage.removeItem('completion_history');
  updateSavedCount();
  showStatus('Historie vymazána');
});

continueBtn16.addEventListener('click', () => continueText(16));
continueBtn256.addEventListener('click', () => continueText(256));

document.addEventListener('click', () => tooltipEl.classList.add('hidden'), { passive: true });
window.addEventListener('DOMContentLoaded', loadTokens);
</script>
</body>
</html>
