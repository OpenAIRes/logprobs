<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Logprobs Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body        { font: 16px/1.5 system-ui, sans-serif; margin: 0; padding: 1rem; }
    #header     { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; }
    #tokens     { max-width: 100%; line-height: 1.5; white-space: normal; }
    .token      { display: inline; cursor: pointer; }
    .token:hover{ background: #ffeaa7; }
    .newline    { display: inline; white-space: normal; }
.newline.only-nl { position: relative; display: inline-block; width: 1ch; height: calc(var(--nl-count, 1) * 1.5em); vertical-align: baseline; }
.newline.only-nl::after { content: ""; position: absolute; inset: 0; cursor: pointer; pointer-events: auto; background: transparent; }
.newline.only-nl:hover::after { background: #ffeaa7; }
    .newline:hover { background: #ffeaa7; }
    .selected   { background: #74b9ff; }

    #tooltip {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      padding: .5rem;
      font: 14px/1.3 monospace;
      box-shadow: 0 2px 6px #0003;
      z-index: 1000;
      max-width: 90vw;
      overflow-x: auto;
    }
    #tooltip.hidden { display:none; }
    #tooltip table  { border-collapse: collapse; margin-top: .25rem; width: 100%; }
    #tooltip th,
    #tooltip td     { padding: .15rem .5rem; border: 1px solid #ddd; }
    #tooltip tr.best td { background: #dfe6e9; font-weight: bold; }
    #loading  { color: #888; }
    button    { padding: 0.4rem 0.8rem; font-size: 14px; cursor: pointer; margin-left: 0.5rem; margin-top: 0.5rem; }
    #status   { font-size: 14px; color: #2d3436; margin-left: 1rem; }
    #status.error { color: #d63031; }
    #savedCount { margin-left: 0.5rem; font-weight: bold; }

    /* Raw object overlay */
    #rawOverlay { position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 1001; }
    #rawOverlay.hidden { display: none; }
    #rawBox { position: fixed; top: 5%; left: 5%; right: 5%; bottom: 5%; background: #fff; box-shadow: 0 10px 30px #0006; display: flex; flex-direction: column; border: 1px solid #ddd; }
    #rawBoxHeader { display: flex; align-items: center; justify-content: space-between; padding: .5rem .75rem; border-bottom: 1px solid #eee; font-weight: 600; }
    #rawClose { border: none; background: transparent; font-size: 20px; line-height: 1; cursor: pointer; }
    #rawPre { flex: 1; margin: 0; padding: .75rem; overflow: auto; font: 13px/1.45 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; white-space: pre; }

    /* newline visualization (override) */
    .nl-hit { display:inline-block; width: 1ch; height: 1.2em; vertical-align: baseline; cursor: pointer; }
    .nl-hit:hover { background: #ffeaa7; }
    .newline.only-nl { position: relative; display: inline; width: auto; height: auto; }
    .newline.only-nl::after { content: none; }
      /* Prompts overlay */
    #promptsOverlay { position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 1001; }
    #promptsOverlay.hidden { display: none; }
    #promptsBox { position: fixed; top: 5%; left: 5%; right: 5%; bottom: 5%; background: #fff; box-shadow: 0 10px 30px #0006; display: flex; flex-direction: column; border: 1px solid #ddd; }
    #promptsBoxHeader { display: flex; align-items: center; justify-content: space-between; padding: .5rem .75rem; border-bottom: 1px solid #eee; font-weight: 600; }
    #promptsClose { border: none; background: transparent; font-size: 20px; line-height: 1; cursor: pointer; }
    #promptsList { flex: 1; overflow: auto; padding: .75rem; font: 14px/1.45 system-ui, sans-serif; }
    #promptsList ul { margin: 0; padding-left: 1.25rem; }
    #promptsList li { margin: .125rem 0; display: flex; align-items: center; }
    #promptsList li button { margin-left: auto; margin-top: 0; padding: 0.1rem 0.3rem; font-size: 12px; }
  </style>
</head>
<body>
  <div id="header">
    <div>
      <span id="loading">Loading tokens…</span>
      <span id="status"></span>
    </div>
    <div>
      <!-- Odebráno tlačítko Pokračovat (16) --><button id="continueBtn4096" hidden>"max_tokens": 4096</button>
<button id="objectBtn" hidden>object</button>
      <button id="promptsBtn" hidden>prompts</button>
<button id="exportBtn" hidden>Export (<span id="savedCount">0</span>)</button>
      <button id="clearBtn" hidden>Clear</button>
      <button id="repairBtn" hidden>repair links</button>
    </div>
  </div>
  <div id="tokens" hidden></div>
  <div id="tooltip" class="hidden"></div>
  <div id="rawOverlay" class="hidden">
    <div id="rawBox">
      <div id="rawBoxHeader">
        <span>Raw object</span>
        <button id="rawClose" aria-label="Close">×</button>
      </div>
      <pre id="rawPre"></pre>
    </div>
  </div>

  <div id="promptsOverlay" class="hidden">
    <div id="promptsBox">
      <div id="promptsBoxHeader">
        <span>Prompts</span>
        <button id="promptsClose" aria-label="Close">×</button>
      </div>
      <div id="promptsList"></div>
    </div>
  </div>

<script>
let allTokens = [];
let safeTokens = [];
let currentCompletionId = null;

const tokensEl = document.getElementById('tokens');
const loadingEl = document.getElementById('loading');
const tooltipEl = document.getElementById('tooltip');
const exportBtn = document.getElementById('exportBtn');
const clearBtn = document.getElementById('clearBtn');const continueBtn4096 = document.getElementById('continueBtn4096');
const objectBtn = document.getElementById('objectBtn');
const rawOverlay = document.getElementById('rawOverlay');
const rawPre = document.getElementById('rawPre');
const rawClose = document.getElementById('rawClose');
const promptsBtn = document.getElementById('promptsBtn');
const promptsOverlay = document.getElementById('promptsOverlay');
const promptsClose = document.getElementById('promptsClose');
const promptsList = document.getElementById('promptsList');
const statusEl = document.getElementById('status');
const savedCountEl = document.getElementById('savedCount');
const repairBtn = document.getElementById('repairBtn');

function escapeToken(tok){return tok.replace(/\n/g,'\\n').replace(/\t/g,'\\t').replace(/ /g,'␣');}
function showStatus(msg){statusEl.textContent=msg;statusEl.classList.remove('error');setTimeout(()=>{statusEl.textContent='';},2000);}
async function updateSavedCount(){ try{ const n = await idbCount(); savedCountEl.textContent = n; }catch{ savedCountEl.textContent = '0'; } }
function toPlainTokens(arr){return (arr||[]).map(t=>typeof t==='string'?t:(t&&typeof t.token==='string'?t.token:String(t)))}

/* ============ INITIAL LOAD ============ */
async function loadTokens() {
  try {
    await migrateFromLocalStorage();
    const res = await fetch('logprobs.json');
    const data = await res.json();

    let firstEntry;
    if (data.object === "text_completion") {
      // Standard completions
      const lp = data.choices[0].logprobs;
      allTokens = lp.tokens.map((t, i) => {
        const sorted = Object.entries(lp.top_logprobs[i])
          .map(([tok, log]) => ({ token: tok, logprob: log }))
          .sort((a, b) => b.logprob - a.logprob);
        return { token: t, logprob: lp.token_logprobs[i], top_logprobs: sorted };
      });
      safeTokens = allTokens.map(t => t.token);
      currentCompletionId = data.id;

      firstEntry = {
        id: data.id,
        object: "text_completion",
        created: data.created || Math.floor(Date.now()/1000),
        model: data.model,
        previous_response_id: null,
        prompt: {
          text: (typeof data.prompt === 'string' ? data.prompt : Array.isArray(data.prompt) ? data.prompt.join('') : ''),
          index: 0,
          logprobs: { tokens: ((typeof data.prompt === 'string' && data.prompt) ? [data.prompt] : (Array.isArray(data.prompt) && data.prompt.length ? [data.prompt.join('')] : [])), token_logprobs: [], top_logprobs: [] }
        },
        choices: [
          {
            text: data.choices[0].text,
            index: 0,
            logprobs: lp,
            finish_reason: data.choices[0].finish_reason
          }
        ],
        usage: data.usage || {
          prompt_tokens: 0,
          completion_tokens: lp.tokens.length,
          total_tokens: lp.tokens.length
        },
        max_tokens: 16,
        temperature: 0,
        seed: 0
      };
    } else if (data.object === "chat.completion") {
      // Chat completions
      const lp = data.choices[0].logprobs;
      allTokens = lp.content.map(item => {
        const sorted = (item.top_logprobs || [])
          .map(t => ({ token: t.token, logprob: t.logprob }))
          .sort((a,b) => b.logprob - a.logprob);
        return { token: item.token, logprob: item.logprob, top_logprobs: sorted };
      });
      safeTokens = allTokens.map(t => t.token);
      currentCompletionId = data.id;

      firstEntry = {
        id: data.id,
        object: "chat.completion",
        created: data.created || Math.floor(Date.now()/1000),
        model: data.model,
        previous_response_id: null,
        prompt: {
          text: "", // Chat prompt se neukládá explicitně
          index: 0,
          logprobs: { tokens: [], token_logprobs: [], top_logprobs: [] }
        },
        choices: [
          {
            text: data.choices[0].message?.content || "",
            index: 0,
            logprobs: {
              tokens: lp.content.map(t => t.token),
              token_logprobs: lp.content.map(t => t.logprob),
              top_logprobs: lp.content.map(t => {
                const obj = {};
                (t.top_logprobs || []).forEach(tt => obj[tt.token] = tt.logprob);
                return obj;
              })
            },
            finish_reason: data.choices[0].finish_reason
          }
        ],
        usage: data.usage,
        max_tokens: 16,
        temperature: 0,
        seed: 0
      };
    } else {
      throw new Error("Unsupported JSON format");
    }

    // Ulož aktuální položku do IndexedDB, aby bylo možné zobrazit její raw data,
    // i když už existují starší záznamy v historii.
    await idbPut(firstEntry);
    await updateSavedCount();

    renderTokens(allTokens);
    exportBtn.hidden = false;
    clearBtn.hidden = false;
    if (continueBtn4096) continueBtn4096.hidden = false;
    if (objectBtn) objectBtn.hidden = false;
    if (promptsBtn) promptsBtn.hidden = false;
    if (repairBtn) repairBtn.hidden = false;
    updateSavedCount();
    loadingEl.remove();
  } catch (err) {
    loadingEl.textContent = 'Error loading logprobs.json: ' + err.message;
    statusEl.textContent = '';
  }
}

/* ============ HISTORY FUNCTIONS ============ */

// ---------- IndexedDB helpers ----------
const DB_NAME = 'logprobsDB';
const DB_VERSION = 1;
const STORE = 'completions';

function idbOpen(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = () => {
      const db = req.result;
      let store;
      if (!db.objectStoreNames.contains(STORE)) {
        store = db.createObjectStore(STORE, { keyPath: 'id' });
      } else {
        store = req.transaction.objectStore(STORE);
      }
      if (store && !store.indexNames.contains('by_created')) { store.createIndex('by_created','created',{unique:false}); }
      if (store && !store.indexNames.contains('by_prompt_text')) { store.createIndex('by_prompt_text','prompt_text',{unique:false}); }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
function idbWithStore(mode, fn){ return idbOpen().then(db=> new Promise((resolve,reject)=>{ const tx=db.transaction(STORE,mode); const store=tx.objectStore(STORE); Promise.resolve(fn(store,tx)).then(res=>{ tx.oncomplete=()=>resolve(res); tx.onerror=()=>reject(tx.error); }).catch(reject); })); }
function extractPromptTextSafe(entry){ try{ const t=entry?.prompt; if(!t) return ''; if(typeof t.text==='string'&&t.text.trim()!=='') return t.text.trim(); const toks=toPlainTokens(t.logprobs?.tokens); if(toks.length) return toks.join(''); return ''; }catch{ return ''; } }
function normalizeEntry(e){ try{ const c=JSON.parse(JSON.stringify(e)); c.prompt_text = extractPromptTextSafe(c); return c; }catch{ return e; } }
async function idbPut(entry){ return idbWithStore('readwrite', store => store.put(normalizeEntry(entry))); }
async function idbBulkPut(arr){ return idbWithStore('readwrite', store => { arr.forEach(e=> store.put(normalizeEntry(e))); }); }
async function idbBulkDelete(ids){ return idbWithStore('readwrite', store => { ids.forEach(id=> store.delete(id)); }); }
async function idbGet(id){ return idbWithStore('readonly', store => new Promise((res,rej)=>{ const r=store.get(id); r.onsuccess=()=>res(r.result||null); r.onerror=()=>rej(r.error);})); }
async function idbGetAll(){ return idbWithStore('readonly', store => new Promise((res,rej)=>{ if(store.getAll){ const r=store.getAll(); r.onsuccess=()=>res(r.result||[]); r.onerror=()=>rej(r.error);} else { const out=[]; const req=store.openCursor(); req.onsuccess=e=>{ const c=e.target.result; if(c){ out.push(c.value); c.continue(); } else res(out); }; req.onerror=()=>rej(req.error); } })); }
async function idbClear(){ return idbWithStore('readwrite', store => store.clear()); }
async function idbCount(){ return idbWithStore('readonly', store => new Promise((res,rej)=>{ const r=store.count(); r.onsuccess=()=>res(r.result||0); r.onerror=()=>rej(r.error);})); }
async function idbQueryByPrompt(p){ p=(p||'').trim(); return idbWithStore('readonly', store => new Promise((res,rej)=>{ let idx; try{ idx=store.index('by_prompt_text'); }catch{} if(idx){ const range=IDBKeyRange.only(p); const r=idx.getAll(range); r.onsuccess=()=>res(r.result||[]); r.onerror=()=>rej(r.error); } else { const out=[]; const req=store.openCursor(); req.onsuccess=e=>{ const c=e.target.result; if(c){ const v=c.value; const t=v?.prompt_text||extractPromptTextSafe(v)||''; if(t.trim()===p) out.push(v); c.continue(); } else res(out); }; req.onerror=()=>rej(req.error); } })); }
async function idbSearch(term){
  const q=(term||'').toLowerCase();
  if(!q) return [];
  const all=await idbGetAll();
  return all.filter(e=>{ try{ return JSON.stringify(e).toLowerCase().includes(q); }catch{ return false; } });
}
async function migrateFromLocalStorage(){ try{ const raw=localStorage.getItem('completion_history'); if(!raw) return; const arr=JSON.parse(raw); if(Array.isArray(arr)&&arr.length){ await idbBulkPut(arr); localStorage.removeItem('completion_history'); await updateSavedCount(); showStatus('Migrated history to IndexedDB'); } }catch{} }


// --- Storage helpers: robust read + compaction + eviction ---
function estimateBytes(str){ try { return new TextEncoder().encode(str).length; } catch { return str.length; } }

function clone(obj){ return JSON.parse(JSON.stringify(obj)); }

// Odlehčení historie: u starších položek odstraníme největší pole (top_logprobs)
function compactHistory(hist, keepLastN=60){
  const out = clone(hist);
  for (let i=0; i<out.length - keepLastN; i++){
    const e = out[i];
    // prompt top_logprobs
    if (e?.prompt?.logprobs?.top_logprobs) e.prompt.logprobs.top_logprobs = [];
    // completion top_logprobs
    const lp = e?.choices?.[0]?.logprobs;
    if (lp?.top_logprobs) e.choices[0].logprobs.top_logprobs = [];
  }
  return out;
}

function persistHistory(hist){
  const key = 'completion_history';
  const downloadBlob = (text, filename) => {
    try {
      const blob = new Blob([text], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
      URL.revokeObjectURL(url);
    } catch {}
  };
  const fmtTs = () => {
    const d = new Date();
    const pad = n => String(n).padStart(2,'0');
    return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  };
  const trySet = (arr) => { const s = JSON.stringify(arr); localStorage.setItem(key, s); return s; };

  try {
    const s = trySet(hist);
    updateSavedCount();
    return {ok:true, evicted:0, exported:0, used: s.length};
  } catch (err) {
    // Bez mačkání: místo kompakce exportujeme nejstarší chunk a smažeme ho, dokud se nevejdeme
    let tmp = JSON.parse(JSON.stringify(hist));
    let removedTotal = 0;
    let exportedCount = 0;
    let chunk = Math.max(10, Math.ceil(tmp.length * 0.25)); // začni čtvrtinou historie (min 10)

    while (tmp.length > 1) {
      const take = Math.min(chunk, Math.max(1, tmp.length - 1));
      const removed = tmp.splice(0, take);
      removedTotal += removed.length;
      // export právě odříznutého bloku
      try {
        const fname = `completion_history_archive_${fmtTs()}_${removed.length}.json`;
        downloadBlob(JSON.stringify(removed), fname);
        exportedCount += removed.length;
      } catch {}
      try {
        const s2 = trySet(tmp);
        updateSavedCount();
        showStatus(`Storage full — exported & cleared ${removedTotal} oldest item(s).`);
        return {ok:true, evicted:removedTotal, exported:exportedCount, used:s2.length};
      } catch (e) {
        // pořád plné: zmenši chunk a zkus znovu
        if (chunk > 1) chunk = Math.max(1, Math.floor(chunk / 2));
        continue;
      }
    }

    alert('Storage is full and cannot be reduced automatically. Please use Export and then Clear.');
    return {ok:false, evicted:0, exported:0, used:0};
  }
}

async function getCompletionById(id) {
  const entry = await idbGet(id);
  if (!entry) return null;

  const history = await idbGetAll();
  const currPromptArr = entry?.prompt?.logprobs?.tokens || [];

  function mapInSource(src){
    if (!src) return null;
    const sp  = (src?.prompt?.logprobs?.tokens) || [];
    const scl = src?.choices?.[0]?.logprobs || null;
    const sct = scl?.tokens || [];
    const stop= scl?.top_logprobs || [];
    if (!scl || sct.length === 0) return null;
    const baseIdx = sp.length;

    // EXAKTNÍ SHODA
    {
      const all = sp.concat(sct);
      if (currPromptArr.length > 0 && all.length >= currPromptArr.length){
        for (let s = 0; s <= all.length - currPromptArr.length; s++){
          let ok = true;
          for (let k = 0; k < currPromptArr.length; k++){
            if (all[s + k] !== currPromptArr[k]) { ok = false; break; }
          }
          if (ok && s >= baseIdx) return { src, baseIdx, start: s, mode: 'exact' };
        }
      }
    }
    // ALT-MATCH
    if (currPromptArr.length > 0 && sct.length >= currPromptArr.length){
      for (let j = baseIdx; j <= baseIdx + sct.length - currPromptArr.length; j++){
        let ok = true;
        for (let k = 0; k < currPromptArr.length; k++){
          const want = currPromptArr[k];
          const idx  = (j - baseIdx) + k; // index do completion části
          const actual = sct[idx];
          const topObj = stop[idx] || {};
          if (!(actual === want || Object.prototype.hasOwnProperty.call(topObj, want))) { ok = false; break; }
        }
        if (ok) return { src, baseIdx, start: j, mode: 'alt' };
      }
    }
    return null;
  }

  let source = history.find(e => e.id === entry.previous_response_id) || null;
  let mapping = mapInSource(source);

  if (!mapping){
    const sorted = [...history].sort((a,b)=> (a.created||0) - (b.created||0));
    for (const cand of sorted){ if (cand.id === entry.id) continue; const m = mapInSource(cand); if (m){ mapping = m; break; } }
  }

  if (mapping && (!entry.previous_response_id || entry.previous_response_id !== mapping.src.id)){
    entry.previous_response_id = mapping.src.id; await idbPut(entry); source = mapping.src;
  } else if (mapping){ source = mapping.src; }

  const srcPrompt     = (source?.prompt?.logprobs?.tokens) || [];
  const srcCompLog    = source?.choices?.[0]?.logprobs || null;
  const srcCompTokens = srcCompLog?.tokens || [];
  const srcCompLPs    = srcCompLog?.token_logprobs || [];
  const srcTopArr     = srcCompLog?.top_logprobs || [];
  const baseIdx       = mapping ? mapping.baseIdx : (source ? srcPrompt.length : 0);
  const subseqStart   = mapping ? mapping.start   : -1;

  const promptTokensUI = (entry.prompt.logprobs.tokens||[]).map((t, i) => {
    let logprob = entry.prompt.logprobs.token_logprobs?.[i] ?? null;
    let top = entry.prompt.logprobs.top_logprobs?.[i] ?? null;
    if ((!top || Object.keys(top).length === 0) && source) {
      let mappedJ = null;
      if (subseqStart >= 0) {
        const abs = subseqStart + i; if (abs >= baseIdx) mappedJ = abs - baseIdx;
      }
      if (mappedJ === null && i >= baseIdx) mappedJ = i - baseIdx;
      if (mappedJ !== null && mappedJ >= 0 && mappedJ < srcCompTokens.length) {
        top = srcTopArr[mappedJ] || {};
        if (logprob == null) {
          if (srcCompTokens[mappedJ] === t) logprob = srcCompLPs[mappedJ];
          else if (top && Object.prototype.hasOwnProperty.call(top, t)) logprob = top[t];
        }
      }
    }
    if (!top) top = {};
    const sorted = Object.entries(top).map(([tok, log]) => ({ token: tok, logprob: log })).sort((a,b)=>b.logprob-a.logprob);
    return { token: t, logprob, top_logprobs: sorted };
  });

  const completionTokensUI = (entry.choices?.[0]?.logprobs?.tokens||[]).map((t, i) => {
    const top = entry.choices[0].logprobs.top_logprobs?.[i] || {};
    const sorted = Object.entries(top).map(([tok, log]) => ({ token: tok, logprob: log })).sort((a,b)=>b.logprob-a.logprob);
    return { token: t, logprob: entry.choices[0].logprobs.token_logprobs?.[i], top_logprobs: sorted };
  });

  return { promptTokens: entry.prompt.logprobs.tokens||[], completionTokens: entry.choices?.[0]?.logprobs?.tokens||[], allTokens: promptTokensUI.concat(completionTokensUI) };
}

/* Removed stray duplicate block that broke script execution */
/* ============ CREATE COMPLETION ============ */
async function createCompletion(prevId, replaceIdx, newToken, maxTokens) {
  const prev = await getCompletionById(prevId);
  if (!prev) {
    console.error('[ERROR] Previous completion not found for ID:', prevId);
    showStatus('Previous completion not found');
    return null;
  }

  const allTokensArr = toPlainTokens(prev.promptTokens.concat(prev.completionTokens));
  const updatedTokens = allTokensArr.slice(0, replaceIdx);
  if (newToken !== undefined && newToken !== null) {
    const plainNew = toPlainTokens([newToken])[0];
    if (plainNew !== undefined && plainNew !== null) updatedTokens.push(plainNew);
  }
  const plainPromptTokens = toPlainTokens(updatedTokens);
  const promptText = plainPromptTokens.join('');

  const candidates = await idbQueryByPrompt(promptText.trim());
  const existing = candidates.find(e => JSON.stringify(e?.prompt?.logprobs?.tokens||[]) === JSON.stringify(plainPromptTokens) && Number((e?.meta?.target_max_tokens ?? e?.max_tokens)) === Number(maxTokens));
  if (existing) {
    console.log('[HIT] Found existing completion');
    return { response: { id: existing.id, choices: existing.choices }, prompt: promptText, fromHistory: true };
  }

  console.log('[MISS] Calling API for prompt:', promptText);

  const key = await ensureApiKey();
  if (!key) return null;

  const data = await fetchCompletionAutoFit(promptText, maxTokens, key);
  if (!data) return null;

  const lp = data.choices[0].logprobs;

  const newEntry = {
    id: data.id,
    object: "text_completion",
    created: Math.floor(Date.now() / 1000),
    model: data.model,
    previous_response_id: prevId,
    prompt: {
      text: promptText,
      index: 0,
      logprobs: { tokens: plainPromptTokens, token_logprobs: [], top_logprobs: [] }
    },
    choices: [
      {
        text: data.choices[0].text,
        index: 0,
        logprobs: lp,
        finish_reason: data.choices[0].finish_reason
      }
    ],
    usage: data.usage,
    max_tokens: Number(data._effective_max_tokens ?? maxTokens),
    temperature: 0,
    seed: 0,
    meta: { target_max_tokens: Number(maxTokens) }
  };

  await idbPut(newEntry);
  await updateSavedCount();

  return { response: data, prompt: promptText, fromHistory: false };
}

/* ============ CONTINUE (PROMPT ONLY) ============ */
async function continueFromPromptOnly(maxTokens) {
  const prevId = currentCompletionId;
  // getCompletionById returns a Promise, so we need to await it here
  const prev = await getCompletionById(prevId);
  if (!prev) {
    console.error('[ERROR] Cannot continue: previous completion not found');
    showStatus('Nelze pokračovat – chybí aktuální záznam');
    return;
  }

  // Použij pouze původní prompt (bez completionu). Fallback pro chat: když není prompt, použij celé zobrazení.
  const promptOnlyIdx = prev.promptTokens.length > 0 ? prev.promptTokens.length : 0;

  const result = await createCompletion(prevId, promptOnlyIdx, undefined, maxTokens);
  if (!result) return;

  const lp = result.response.choices[0].logprobs;
  const newTokens = lp.tokens.map((t, i) => {
    const sorted = Object.entries(lp.top_logprobs[i])
      .map(([tok, log]) => ({ token: tok, logprob: log }))
      .sort((a, b) => b.logprob - a.logprob);
    return { token: t, logprob: lp.token_logprobs[i], top_logprobs: sorted };
  });
  const promptLen = prev.promptTokens.length > 0 ? prev.promptTokens.length : allTokens.length;
  allTokens = allTokens.slice(0, promptLen).concat(newTokens);
  safeTokens = allTokens.map(t => t.token);
  currentCompletionId = result.response.id;
  renderTokens(allTokens);
  showStatus(result.fromHistory ? 'Načteno!' : 'Pokračování (z promptu) nahrazeno!');
}

/* ============ API HELPER ============ */
async function fetchCompletion(prompt, maxTokens, key){
  try{
    const res = await fetch('https://api.openai.com/v1/completions',{
      method:'POST',
      headers:{
        'Content-Type':'application/json',
        'Authorization':`Bearer ${key||await ensureApiKey()}`
      },
      body:JSON.stringify({
        model:'gpt-3.5-turbo-instruct',
        prompt,
        logprobs:20,
        max_tokens:maxTokens,
        temperature:0,
        seed:0
      })
    });
    const data = await res.json(); 
    if(data.error){
      statusEl.textContent=`Error: ${data.error.message}`; 
      statusEl.classList.add('error'); 
      return null;
    }
    return data;
  }catch{return null;}
}

/* ============ AUTO-FIT WRAPPER ============ */
async function fetchCompletionAutoFit(prompt, maxTokens, key){
  async function callOnce(effectiveMax){
    const res = await fetch('https://api.openai.com/v1/completions',{
      method:'POST',
      headers:{
        'Content-Type':'application/json',
        'Authorization':`Bearer ${key||await ensureApiKey()}`
      },
      body:JSON.stringify({
        model:'gpt-3.5-turbo-instruct',
        prompt,
        logprobs:20,
        max_tokens: effectiveMax,
        temperature:0,
        seed:0
      })
    });
    const data = await res.json();
    return data;
  }
  try{
    let effectiveMax = maxTokens;
    let data = await callOnce(effectiveMax);
    if(data && data.error && typeof data.error.message === 'string'){
      const msg = data.error.message;
      // const re = new RegExp('maximum context length is\s+(\d+) tokens[\s\S]*?\((\d+) in your prompt;\s*(\d+) for the completion\)','i');
      const m = msg.match(new RegExp("maximum context length is\s+(\d+) tokens[\s\S]*?\((\d+) in your prompt;\s*(\d+) for the completion\)","i"));
      if(m){
        const limit = parseInt(m[1],10);
        const promptCount = parseInt(m[2],10);
        const allowed = Math.max(1, limit - promptCount);
        if(allowed < effectiveMax){
          effectiveMax = allowed;
          data = await callOnce(effectiveMax);
        }
      } else {
        // Fallback: vytáhni čísla bez regex escape problémů
        const nums = [];
        let cur = '';
        for (let ch of msg) {
          if (ch >= '0' && ch <= '9') { cur += ch; }
          else if (cur) { nums.push(parseInt(cur,10)); cur = ''; }
        }
        if (cur) nums.push(parseInt(cur,10));
        if (nums.length >= 3) {
          const limit = nums[0];
          const promptCount = nums[2];
          const allowed = Math.max(1, limit - promptCount);
          if (allowed < effectiveMax) {
            effectiveMax = allowed;
            data = await callOnce(effectiveMax);
          }
        }
      }
    }
    if(data && !data.error){ data._effective_max_tokens = effectiveMax; return data; }
    if(data && data.error){ statusEl.textContent=`Error: ${data.error.message}`; statusEl.classList.add('error'); return null; }
    return null;
  }catch(err){ return null; }
}

/* ============ APPLY COMPLETION ============ */
function applyCompletion(response, idx, replacementToken){
  const lp=response.choices[0].logprobs;
  const newTokens=lp.tokens.map((t,i)=>{
    const sorted=Object.entries(lp.top_logprobs[i])
      .map(([tok,log])=>({token:tok,logprob:log}))
      .sort((a,b)=>b.logprob-a.logprob);
    return {token:t,logprob:lp.token_logprobs[i],top_logprobs:sorted};
  });

  const replacedObj={token:replacementToken,logprob:0,top_logprobs:allTokens[idx]?.top_logprobs||[]};
  allTokens=allTokens.slice(0,idx).concat(replacedObj,newTokens);
  safeTokens=allTokens.map(t=>t.token);
  currentCompletionId=response.id;
  renderTokens(allTokens); 
  tooltipEl.classList.add('hidden');
}

/* ============ UI RENDERING ============ */
function renderTokens(tokens){
  tokensEl.innerHTML=''; let i=0; const BATCH=1200;
  function chunk(){
    const frag=document.createDocumentFragment();
    for(let j=0;j<BATCH&&i<tokens.length;j++,i++){
      const t=tokens[i];
      const span=document.createElement('span');
      span.dataset.idx=i;
      if (t.token.indexOf('\n') !== -1) {
        const count = (t.token.match(/\n/g) || []).length;
        const onlyNL = t.token.replace(/\n/g,'') === '';
        span.className = 'token newline' + (onlyNL ? ' only-nl' : '');
        if (onlyNL) {
          for (let k = 0; k < count; k++) {
            const hit = document.createElement('span');
            hit.className = 'nl-hit';
            span.appendChild(hit);
            span.appendChild(document.createElement('br'));
          }
        } else {
          const parts = t.token.split('\n');
          for (let p = 0; p < parts.length; p++) {
            if (parts[p]) span.appendChild(document.createTextNode(parts[p]));
            if (p < parts.length - 1) span.appendChild(document.createElement('br'));
          }
        }

      } else {
        span.className = 'token';
        span.textContent = t.token;
      }
      span.title=escapeToken(t.token);
      span.addEventListener('click',e=>handleTokenClick(e,tokens));
      frag.appendChild(span);
    }
    tokensEl.appendChild(frag);
    if(i<tokens.length){requestAnimationFrame(chunk);}else{tokensEl.hidden=false;}
  }
  chunk();
}

function clearSelection(){tokensEl.querySelectorAll('.selected').forEach(el=>el.classList.remove('selected'));}
function handleTokenClick(e,tokens){
  e.stopPropagation();
  const idx=+e.currentTarget.dataset.idx;
  clearSelection();
  showTopLogprobs(e,tokens,idx);
}

function showTopLogprobs(e,tokens,idx){
  const {token,top_logprobs}=tokens[idx];
  const rows=top_logprobs.slice(0,20).map((r,idx2)=>`<tr class="${idx2===0?'best':''}"><td class="tok" data-idx="${idx}" data-alt="${r.token}">${escapeToken(r.token)}</td><td>${r.logprob.toFixed(2)}</td><td>${Math.exp(r.logprob).toFixed(6)}</td></tr>`).join('');
  tooltipEl.innerHTML=`<strong data-idx="${idx}">Token: "${escapeToken(token)}"</strong><br><table><tr><th>token</th><th>log p</th><th>p</th></tr>${rows}</table>`;
  tooltipEl.classList.remove('hidden'); 
  tooltipEl.querySelectorAll('.tok').forEach(td=>td.addEventListener('click',completion)); 
  positionTooltip(e);
}

function positionTooltip(e){
  const rect = e.currentTarget.getBoundingClientRect();

  // Zviditelnit kvůli měření, ale neukazovat
  const prevVis = tooltipEl.style.visibility;
  tooltipEl.classList.remove('hidden');
  tooltipEl.style.visibility = 'hidden';
  tooltipEl.style.top = '0px';
  tooltipEl.style.left = '0px';

  const tRect = tooltipEl.getBoundingClientRect();

  let top  = rect.bottom + window.scrollY + 4;
  let left = rect.left   + window.scrollX;

  // hranice viewportu
  const vwLeft  = window.scrollX;
  const vwRight = window.scrollX + window.innerWidth;
  const vwTop   = window.scrollY;
  const vwBot   = window.scrollY + window.innerHeight;

  if (left + tRect.width > vwRight) left = vwRight - tRect.width - 4;
  if (top  + tRect.height > vwBot)  top  = rect.top + window.scrollY - tRect.height - 4;
  if (left < vwLeft) left = vwLeft + 4;
  if (top  < vwTop)  top  = rect.bottom + window.scrollY + 4;

  tooltipEl.style.top = `${top}px`;
  tooltipEl.style.left = `${left}px`;
  tooltipEl.style.visibility = prevVis || '';
}
  
async function completion(e){
  e.stopPropagation();
  const idx=+e.currentTarget.dataset.idx;
  const altToken=e.currentTarget.dataset.alt; if(altToken===undefined) return;
  const result=await createCompletion(currentCompletionId,idx,altToken,16);
  if(!result) return;
  applyCompletion(result.response,idx,altToken);
  showStatus(result.fromHistory ? 'Načteno!' : 'Uloženo!');
}

async function ensureApiKey(){
  let key=localStorage.getItem('openai_key'); 
  if(!key){
    key=window.prompt('OpenAI API key:'); 
    if(!key) return null; 
    localStorage.setItem('openai_key',key);
  } 
  return key;
}

/* ============ EXPORT / CLEAR ============ */
exportBtn.addEventListener('click', async ()=>{
  const arr = await idbGetAll();
  if(!arr || !arr.length){ alert('No completions saved yet.'); return; }
  const json = JSON.stringify(arr);
  const blob=new Blob([json],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='completion_history.json'; a.click(); URL.revokeObjectURL(url);
});

clearBtn.addEventListener('click', async ()=>{
  await idbClear();
  await updateSavedCount();
  showStatus('Historie vymazána');
});

// Nové chování: pokračovat z POUHÉHO promptu
// Nové tlačítko 4096
if (continueBtn4096) continueBtn4096.addEventListener('click',()=>continueFromPromptOnly(4096));

document.addEventListener('click',()=>tooltipEl.classList.add('hidden'),{passive:true});
window.addEventListener('DOMContentLoaded',loadTokens);

// =========== RAW OBJECT VIEWER ===========
async function showCurrentRaw(){
  try{
    const entry = await idbGet(currentCompletionId);
    if(!entry){ showStatus('Nenalezen aktuální záznam'); return; }
    rawPre.textContent = JSON.stringify(entry, null, 2);
    rawOverlay.classList.remove('hidden');
  }catch(err){ showStatus('Chyba při čtení raw dat'); }
}
if (objectBtn) objectBtn.addEventListener('click', showCurrentRaw);
if (rawClose) rawClose.addEventListener('click', ()=> rawOverlay.classList.add('hidden'));
if (rawOverlay) rawOverlay.addEventListener('click', (e)=>{ if(e.target===rawOverlay) rawOverlay.classList.add('hidden'); });
window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') rawOverlay.classList.add('hidden'); });

// =========== PROMPTS VIEWER ===========
function extractPromptText(entry){
  try{
    const t = entry?.prompt;
    if(!t) return '';
    if (typeof t.text === 'string' && t.text.trim() !== '') return t.text;
    const toks = toPlainTokens(t.logprobs?.tokens);
    if (toks.length) return toks.join('');
    return '';
  }catch{ return ''; }
}
function formatDt(epoch){ try{ if(!epoch) return ''; const d=new Date(Number(epoch)*1000); return d.toLocaleString(); }catch{ return ''; } }
async function openEntryById(id){
  try{
    const view = await getCompletionById(id);
    if(!view){ showStatus('Záznam nenalezen'); return; }
    allTokens = view.allTokens;
    safeTokens = allTokens.map(t=>t.token);
    currentCompletionId = id;
    renderTokens(allTokens);
    promptsOverlay.classList.add('hidden');
    showStatus('Načteno z historie');
  }catch{ showStatus('Chyba při otevírání záznamu'); }
}
async function showPromptMatches(promptStr){
  const matches = await idbQueryByPrompt(promptStr);
  if(matches.length===0){ showStatus('Žádné záznamy pro tento prompt'); return; }
  matches.sort((a,b)=> (b.created||0)-(a.created||0));
  const ul = document.createElement('ul');
  matches.forEach(e=>{ const li=document.createElement('li'); const a=document.createElement('a'); a.href='#'; a.textContent = `${formatDt(e.created)} — ${e.id}`; a.addEventListener('click',(ev)=>{ ev.preventDefault(); openEntryById(e.id); }); li.appendChild(a); ul.appendChild(li); });
  promptsList.innerHTML=''; const back=document.createElement('button'); back.textContent='← Zpět'; back.style.marginBottom='.5rem'; back.addEventListener('click', showPrompts); promptsList.appendChild(back); promptsList.appendChild(ul);
}
async function deletePrompt(promptStr){
  try{
    const matches = await idbQueryByPrompt(promptStr);
    if(matches.length===0){ showStatus('Žádné záznamy k odstranění'); return; }
    await idbBulkDelete(matches.map(m=>m.id));
    await updateSavedCount();
    showStatus('Prompt odstraněn');
    showPrompts();
  }catch(err){ showStatus('Chyba při mazání promptu'); }
}
async function showSearchResults(query){
  const matches = await idbSearch(query);
  if(matches.length===0){ showStatus('Žádné záznamy pro hledaný text'); return; }
  matches.sort((a,b)=> (b.created||0)-(a.created||0));
  const ul = document.createElement('ul');
  matches.forEach(e=>{ const li=document.createElement('li'); const a=document.createElement('a'); a.href='#'; a.textContent=`${formatDt(e.created)} — ${e.id}`; a.addEventListener('click',(ev)=>{ ev.preventDefault(); openEntryById(e.id); }); li.appendChild(a); ul.appendChild(li); });
  promptsList.innerHTML=''; const back=document.createElement('button'); back.textContent='← Zpět'; back.style.marginBottom='.5rem'; back.addEventListener('click', showPrompts); promptsList.appendChild(back); promptsList.appendChild(ul);
}
async function showPrompts(){
  try{
    const history = await idbGetAll();
    const prompts = history.map(extractPromptText).map(s=> (s||'').trim()).filter(Boolean);
    const uniq = Array.from(new Set(prompts)).sort((a,b)=>a.localeCompare(b));
    if (uniq.length === 0) { showStatus('Žádné prompty v historii'); return; }
    const searchDiv=document.createElement('div');
    const searchInput=document.createElement('input'); searchInput.type='text'; searchInput.placeholder='Search…';
    const searchBtn=document.createElement('button'); searchBtn.textContent='Search';
    searchBtn.addEventListener('click',()=>{ const q=searchInput.value.trim(); if(q) showSearchResults(q); });
    searchInput.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ e.preventDefault(); searchBtn.click(); } });
    searchDiv.appendChild(searchInput); searchDiv.appendChild(searchBtn); searchDiv.style.marginBottom='.5rem';
    const ul = document.createElement('ul');
    uniq.forEach(p=>{
      const li=document.createElement('li');
      const a=document.createElement('a'); a.href='#'; a.textContent=p; a.addEventListener('click',(e)=>{e.preventDefault(); showPromptMatches(p);});
      const btn=document.createElement('button'); btn.textContent='Smazat'; btn.addEventListener('click', async (e)=>{ e.preventDefault(); e.stopPropagation(); await deletePrompt(p); });
      li.appendChild(a); li.appendChild(btn); ul.appendChild(li);
    });
    promptsList.innerHTML=''; promptsList.appendChild(searchDiv); promptsList.appendChild(ul); promptsOverlay.classList.remove('hidden');
  }catch(err){ showStatus('Chyba při čtení promptů'); }
}
if (promptsBtn) promptsBtn.addEventListener('click', showPrompts);
if (promptsClose) promptsClose.addEventListener('click', ()=> promptsOverlay.classList.add('hidden'));
if (promptsOverlay) promptsOverlay.addEventListener('click', (e)=>{ if(e.target===promptsOverlay) promptsOverlay.classList.add('hidden'); });
window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') promptsOverlay.classList.add('hidden'); });

// =========== REPAIR PROMPT TOKEN IDS ==========
async function repairLinks() {
  const history = await idbGetAll();
  if (!Array.isArray(history) || history.length === 0) {
    showStatus('Historie je prázdná');
    return;
  }

  const getPromptTokens = (e) =>
    Array.isArray(e?.prompt?.logprobs?.tokens) ? e.prompt.logprobs.tokens : [];
  const getCompletionTokens = (e) => {
    const lp = e?.choices?.[0]?.logprobs;
    if (!lp) return [];
    if (Array.isArray(lp.tokens)) return lp.tokens;                    // text_completion
    if (Array.isArray(lp.content)) return lp.content.map(t => t.token); // chat.completion
    return [];
  };

  const entries = history.map(e => ({
    entry: e,
    promptTokens: getPromptTokens(e),
    fullTokens: getPromptTokens(e).concat(getCompletionTokens(e)),
    created: e.created || 0
  })).sort((a, b) => a.created - b.created);

  const INITIAL_ID = 'cmpl-Bxpc9AqOf2sIPVVJ9hStmVtyNXV9O';

  for (const target of entries) {
    const ptoks = target.promptTokens;
    if (!target.entry.prompt) target.entry.prompt = {};
    if (!target.entry.prompt.logprobs) target.entry.prompt.logprobs = {};
    const idsPerToken = new Array(ptoks.length).fill(null).map(() => []);

    if (ptoks.length > 0) idsPerToken[0] = [INITIAL_ID];

    // i = index tokenu v promptu; pro i>=1 používáme prefix prvních i tokenů
    for (let i = 1; i < ptoks.length; i++) {
      const prefixLen = i;                  // pro 2. token bereme jen 1. token
      const threshold = i + 1;              // prompt kandidáta musí mít < threshold tokenů
      const prefix = ptoks.slice(0, prefixLen);
      const candidates = [];

      for (const cand of entries) {
        if (cand.entry.id === target.entry.id) continue;
        if (cand.created >= target.created) continue;
        if (cand.promptTokens.length >= threshold) continue;   // prompt < (i+1)
        if (cand.fullTokens.length < prefixLen) continue;

        let ok = true;
        for (let j = 0; j < prefixLen; j++) {
          if (cand.fullTokens[j] !== prefix[j]) { ok = false; break; }
        }
        if (!ok) continue;

        candidates.push({
          id: cand.entry.id,
          promptLen: cand.promptTokens.length,
          created: cand.created
        });
      }

      candidates.sort((a, b) => (b.promptLen - a.promptLen) || (a.created - b.created));
      idsPerToken[i] = candidates.map(c => c.id);
    }

    target.entry.prompt.logprobs.ids = idsPerToken;
  }

  await idbBulkPut(history);
  await updateSavedCount();
  showStatus('Repair: doplněna ids podle nových prefix pravidel');
}
if (repairBtn) repairBtn.addEventListener('click', repairLinks);

</script>
</body>
</html>
