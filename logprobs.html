<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Logprobs Viewer (token-safe version)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body        { font: 16px/1.5 system-ui, sans-serif; margin: 0; padding: 1rem; }
    #header     { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; }
    #tokens     { max-width: 100%; line-height: 1.5; white-space: normal; }
    .token      { display: inline; cursor: pointer; }
    .token:hover{ background: #ffeaa7; }
    .newline    { display: block; width: 100%; }
    .newline:hover { background: #ffeaa7; }
    .selected   { background: #74b9ff; }

    #tooltip {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      padding: .5rem;
      font: 14px/1.3 monospace;
      box-shadow: 0 2px 6px #0003;
      z-index: 1000;
      max-width: 90vw;
      overflow-x: auto;
    }
    #tooltip.hidden { display:none; }
    #tooltip table  { border-collapse: collapse; margin-top: .25rem; width: 100%; }
    #tooltip th,
    #tooltip td     { padding: .15rem .5rem; border: 1px solid #ddd; }
    #tooltip tr.best td { background: #dfe6e9; font-weight: bold; }
    #loading  { color: #888; }
    button    { padding: 0.4rem 0.8rem; font-size: 14px; cursor: pointer; margin-left: 0.5rem; margin-top: 0.5rem; }
    #status   { font-size: 14px; color: #2d3436; margin-left: 1rem; }
    #status.error { color: #d63031; }
    #savedCount { margin-left: 0.5rem; font-weight: bold; }
  </style>
</head>
<body>
  <div id="header">
    <div>
      <span id="loading">Loading tokens…</span>
      <span id="status"></span>
    </div>
    <div>
      <button id="continueBtn16" hidden>Pokračovat (16)</button>
      <button id="continueBtn256" hidden>Pokračovat (256)</button>
      <button id="exportBtn" hidden>Export (<span id="savedCount">0</span>)</button>
      <button id="clearBtn" hidden>Clear</button>
    </div>
  </div>
  <div id="tokens" hidden></div>
  <div id="tooltip" class="hidden"></div>

<script>
/* =====================================================
   GLOBAL STATE
   ===================================================== */
const tokensEl       = document.getElementById('tokens');
const loadingEl      = document.getElementById('loading');
const tooltipEl      = document.getElementById('tooltip');
const exportBtn      = document.getElementById('exportBtn');
const clearBtn       = document.getElementById('clearBtn');
const continueBtn16  = document.getElementById('continueBtn16');
const continueBtn256 = document.getElementById('continueBtn256');
const statusEl       = document.getElementById('status');
const savedCountEl   = document.getElementById('savedCount');

let allTokens  = [];  
let safeTokens = [];  
let currentCompletionId = null;

/* =====================================================
   HELPERS
   ===================================================== */
function escapeToken(tok){return tok.replace(/\n/g,'\\n').replace(/\t/g,'\\t').replace(/ /g,'␣');}
function showStatus(msg){statusEl.textContent=msg;statusEl.classList.remove('error');setTimeout(()=>{statusEl.textContent='';},2000);}
function updateSavedCount(){const h=JSON.parse(localStorage.getItem('completion_history')||'[]');savedCountEl.textContent=h.length;}

/* =====================================================
   LOAD TOKENS (INITIAL)
   ===================================================== */
async function loadTokens() {
  try {
    const res = await fetch('logprobs.json');
    const data = await res.json();

    const lp = data.choices[0].logprobs;

    const firstEntry = {
      timestamp: new Date().toISOString(),
      model: data.model,
      seed: 0,
      temperature: 0,
      max_tokens: 16,
      system_fingerprint: data.system_fingerprint || null,
      prompt: {
        text: (data.prompt && data.prompt.length ? data.prompt.map(p => p.content || '').join('') : ''),
        tokens: [],
        logprobs: []
      },
      completion: {
        id: data.id,
        text: data.choices[0].text,
        tokens: lp.tokens,
        token_logprobs: lp.token_logprobs,
        top_logprobs: lp.top_logprobs
      }
    };

    const history = JSON.parse(localStorage.getItem('completion_history') || '[]');
    if (history.length === 0) {
      history.push(firstEntry);
      localStorage.setItem('completion_history', JSON.stringify(history));
    }

    allTokens = lp.tokens.map((t, i) => {
      const sorted = Object.entries(lp.top_logprobs[i])
        .map(([tok, log]) => ({ token: tok, logprob: log }))
        .sort((a, b) => b.logprob - a.logprob);
      return { token: t, logprob: lp.token_logprobs[i], top_logprobs: sorted };
    });

    safeTokens = allTokens.map(t => t.token);
    currentCompletionId = data.id;

    renderTokens(allTokens);
    exportBtn.hidden = false;
    clearBtn.hidden = false;
    continueBtn16.hidden = false;
    continueBtn256.hidden = false;
    updateSavedCount();
  } catch (err) {
    loadingEl.textContent = 'Error loading logprobs.json: ' + err.message;
    statusEl.textContent = '';
  }
}

/* =====================================================
   HISTORY UTILITIES
   ===================================================== */
function getCompletionById(id) {
  const history = JSON.parse(localStorage.getItem('completion_history') || '[]');
  const entry = history.find(e => e.completion.id === id);
  if (!entry) return null;

  return {
    promptTokens: entry.prompt.tokens,
    completionTokens: entry.completion.tokens,
    allTokens: entry.prompt.tokens.concat(entry.completion.tokens)
  };
}

/* =====================================================
   API REQUESTS
   ===================================================== */
async function createCompletion(prevId, replaceIdx, newToken, maxTokens) {
  const prev = getCompletionById(prevId);
  if (!prev) {
    statusEl.textContent = 'Previous completion not found';
    statusEl.classList.add('error');
    return null;
  }

  const allTokens = prev.allTokens;
  const updatedTokens = allTokens.slice(0, replaceIdx).concat(newToken);
  const prompt = updatedTokens.join('');

  const key = await ensureApiKey();
  if (!key) return null;

  const data = await fetchCompletion(prompt, maxTokens, key);
  if (!data) return null;

  const lp = data.choices[0].logprobs;

  const history = JSON.parse(localStorage.getItem('completion_history') || '[]');
  history.push({
    timestamp: new Date().toISOString(),
    model: data.model,
    seed: 0,
    temperature: 0,
    max_tokens: maxTokens,
    system_fingerprint: data.system_fingerprint || null,
    prompt: {
      text: prompt,
      tokens: updatedTokens,
      logprobs: [] 
    },
    completion: {
      id: data.id,
      text: data.choices[0].text,
      tokens: lp.tokens,
      token_logprobs: lp.token_logprobs,
      top_logprobs: lp.top_logprobs
    }
  });
  localStorage.setItem('completion_history', JSON.stringify(history));
  updateSavedCount();

  return { response: data, prompt, fromHistory: false };
}

async function fetchCompletion(prompt, maxTokens, key){
  try{
    const res = await fetch('https://api.openai.com/v1/completions',{
      method:'POST',
      headers:{
        'Content-Type':'application/json',
        'Authorization':`Bearer ${key||await ensureApiKey()}`
      },
      body:JSON.stringify({
        model:'gpt-3.5-turbo-instruct',
        prompt,
        logprobs:20,
        max_tokens:maxTokens,
        temperature:0,
        seed:0
      })
    });
    const data = await res.json(); 
    if(data.error){
      statusEl.textContent=`Error: ${data.error.message}`; 
      statusEl.classList.add('error'); 
      return null;
    }
    return data;
  }catch{return null;}
}

/* =====================================================
   TOKEN LIST MUTATIONS
   ===================================================== */
function applyCompletion(response, idx, replacementToken){
  const lp=response.choices[0].logprobs;
  const newTokens=lp.tokens.map((t,i)=>{
    const sorted=Object.entries(lp.top_logprobs[i])
      .map(([tok,log])=>({token:tok,logprob:log}))
      .sort((a,b)=>b.logprob-a.logprob);
    return {token:t,logprob:lp.token_logprobs[i],top_logprobs:sorted};
  });

  const replacedObj={token:replacementToken,logprob:0,top_logprobs:allTokens[idx]?.top_logprobs||[]};
  allTokens=allTokens.slice(0,idx).concat(replacedObj,newTokens);
  safeTokens=allTokens.map(t=>t.token);
  currentCompletionId=response.id;
  renderTokens(allTokens); 
  tooltipEl.classList.add('hidden');
}

/* =====================================================
   UI RENDERING & TOOLTIP
   ===================================================== */
function renderTokens(tokens){
  tokensEl.innerHTML=''; let i=0; const BATCH=1200;
  function chunk(){
    const frag=document.createDocumentFragment();
    for(let j=0;j<BATCH&&i<tokens.length;j++,i++){
      const t=tokens[i];
      const span=document.createElement('span');
      span.dataset.idx=i;
      if(t.token.includes('\n')){
        span.className='token newline';
        span.style.height=`${1.2*(t.token.match(/\n/g)||[]).length}em`;
      }else{ span.className='token'; span.textContent=t.token; }
      span.title=escapeToken(t.token);
      span.addEventListener('click',e=>handleTokenClick(e,tokens));
      frag.appendChild(span);
    }
    tokensEl.appendChild(frag);
    if(i<tokens.length){requestAnimationFrame(chunk);}else{loadingEl.remove();tokensEl.hidden=false;}
  }
  chunk();
}

function clearSelection(){tokensEl.querySelectorAll('.selected').forEach(el=>el.classList.remove('selected'));}
function handleTokenClick(e,tokens){
  e.stopPropagation();
  const idx=+e.currentTarget.dataset.idx;
  clearSelection();
  showTopLogprobs(e,tokens,idx);
}

function showTopLogprobs(e,tokens,idx){
  const {token,top_logprobs}=tokens[idx];
  const rows=top_logprobs.slice(0,20).map((r,idx2)=>`<tr class="${idx2===0?'best':''}"><td class="tok" data-idx="${idx}" data-alt="${r.token}">${escapeToken(r.token)}</td><td>${r.logprob.toFixed(2)}</td><td>${Math.exp(r.logprob).toFixed(6)}</td></tr>`).join('');
  tooltipEl.innerHTML=`<strong data-idx="${idx}">Token: "${escapeToken(token)}"</strong><br><table><tr><th>token</th><th>log p</th><th>p</th></tr>${rows}</table>`;
  tooltipEl.classList.remove('hidden'); 
  tooltipEl.querySelectorAll('.tok').forEach(td=>td.addEventListener('click',completion)); 
  positionTooltip(e);
}

function positionTooltip(e){
  const rect=e.currentTarget.getBoundingClientRect();
  const tRect=tooltipEl.getBoundingClientRect();
  let top=rect.bottom+window.scrollY+4;
  let left=rect.left+window.scrollX;
  if(left+tRect.width>window.innerWidth){left=window.innerWidth-tRect.width-4;}
  if(top+tRect.height>window.innerHeight+window.scrollY){top=rect.top+window.scrollY-tRect.height-4;}
  tooltipEl.style.top=`${top}px`;
  tooltipEl.style.left=`${left}px`;
}

async function completion(e){
  e.stopPropagation();
  const idx=+e.currentTarget.dataset.idx;
  const altToken=e.currentTarget.dataset.alt; if(altToken===undefined) return;
  const result=await createCompletion(currentCompletionId,idx,altToken,16);
  if(!result) return;
  applyCompletion(result.response,idx,altToken);
  showStatus('Uloženo!');
}

async function ensureApiKey(){
  let key=localStorage.getItem('openai_key'); 
  if(!key){
    key=window.prompt('OpenAI API key:'); 
    if(!key) return null; 
    localStorage.setItem('openai_key',key);
  } 
  return key;
}

/* =====================================================
   EXPORT / CLEAR BUTTONS
   ===================================================== */
exportBtn.addEventListener('click',()=>{
  const h=localStorage.getItem('completion_history'); 
  if(!h||h==='[]'){alert('No completions saved yet.');return;} 
  const blob=new Blob([h],{type:'application/json'}); 
  const url=URL.createObjectURL(blob); 
  const a=document.createElement('a'); 
  a.href=url; a.download='completion_history.json'; 
  a.click(); 
  URL.revokeObjectURL(url);
});

clearBtn.addEventListener('click',()=>{
  localStorage.removeItem('completion_history'); 
  updateSavedCount(); 
  showStatus('Historie vymazána');
});
continueBtn16.addEventListener('click',()=>continueText(16));
continueBtn256.addEventListener('click',()=>continueText(256));

document.addEventListener('click',()=>tooltipEl.classList.add('hidden'),{passive:true});
window.addEventListener('DOMContentLoaded',loadTokens);
</script>
</body>
</html>
